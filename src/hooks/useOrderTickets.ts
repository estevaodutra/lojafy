import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext';
import { toast } from '@/hooks/use-toast';
import type { OrderTicket, OrderTicketStatus, OrderTicketType, TicketFilters } from '@/types/orderTickets';
import type { TicketAttachment } from '@/components/order-tickets/TicketAttachmentUpload';

interface CreateTicketDataWithAttachments {
  order_id: string;
  tipo: OrderTicketType;
  reason: string;
  attachments?: TicketAttachment[];
}
export const useOrderTickets = (filters?: TicketFilters) => {
  const { user, profile } = useAuth();
  const queryClient = useQueryClient();

  // Fetch tickets based on user role
  const { data: tickets, isLoading, error, refetch } = useQuery({
    queryKey: ['order-tickets', user?.id, filters],
    queryFn: async () => {
      if (!user) return [];

      let query = supabase
        .from('order_tickets')
        .select(`
          *,
          order:orders!order_id (
            order_number,
            status,
            payment_status,
            total_amount
          )
        `)
        .order('created_at', { ascending: false });

      // Apply filters
      if (filters?.status && filters.status !== 'all') {
        query = query.eq('status', filters.status);
      }
      if (filters?.tipo && filters.tipo !== 'all') {
        query = query.eq('tipo', filters.tipo);
      }
      if (filters?.search) {
        query = query.or(`ticket_number.ilike.%${filters.search}%,reason.ilike.%${filters.search}%`);
      }

      const { data, error } = await query;

      if (error) throw error;
      return data as OrderTicket[];
    },
    enabled: !!user,
  });

  // Get single ticket by ID
  const getTicketById = async (ticketId: string): Promise<OrderTicket | null> => {
    const { data, error } = await supabase
      .from('order_tickets')
      .select(`
        *,
        order:orders!order_id (
          order_number,
          status,
          payment_status,
          total_amount
        )
      `)
      .eq('id', ticketId)
      .single();

    if (error) {
      console.error('Error fetching ticket:', error);
      return null;
    }

    return data as OrderTicket;
  };

  // Create new ticket
  const createTicketMutation = useMutation({
    mutationFn: async (data: CreateTicketDataWithAttachments) => {
      if (!user) throw new Error('User not authenticated');

      // Calculate SLA deadlines
      const now = new Date();
      const slaConfig = {
        cancelamento: { firstResponse: 4, resolution: 24 },
        reembolso: { firstResponse: 24, resolution: 72 },
        troca: { firstResponse: 24, resolution: 168 },
      };
      
      const sla = slaConfig[data.tipo];
      const slaFirstResponse = new Date(now.getTime() + sla.firstResponse * 60 * 60 * 1000);
      const slaResolution = new Date(now.getTime() + sla.resolution * 60 * 60 * 1000);

      // Get order details to determine responsible
      const { data: order, error: orderError } = await supabase
        .from('orders')
        .select('reseller_id, user_id')
        .eq('id', data.order_id)
        .single();

      if (orderError) throw orderError;

      // For now, we'll set reseller as responsible for reembolso
      // and null for others (to be assigned via n8n or edge function)
      let currentResponsible: string | null = null;
      let resellerId: string | null = null;
      let supplierId: string | null = null;

      if (data.tipo === 'reembolso' && order.reseller_id) {
        currentResponsible = order.reseller_id;
        resellerId = order.reseller_id;
      }

      const ticketData = {
        order_id: data.order_id,
        ticket_number: '', // Will be auto-generated by trigger
        tipo: data.tipo as 'reembolso' | 'troca' | 'cancelamento',
        status: 'aberto' as const,
        reason: data.reason,
        customer_id: user.id,
        reseller_id: resellerId,
        supplier_id: supplierId,
        current_responsible: currentResponsible,
        sla_first_response: slaFirstResponse.toISOString(),
        sla_resolution: slaResolution.toISOString(),
      };

      const { data: ticket, error } = await supabase
        .from('order_tickets')
        .insert(ticketData)
        .select()
        .single();

      if (error) throw error;

      // Create initial message
      await supabase.from('order_ticket_messages').insert({
        ticket_id: ticket.id,
        author_id: user.id,
        author_type: 'cliente' as const,
        message: data.reason,
      });

      // Save attachments if provided
      if (data.attachments && data.attachments.length > 0) {
        const attachmentRecords = data.attachments.map(att => ({
          ticket_id: ticket.id,
          message_id: null,
          file_url: att.url,
          file_name: att.name,
          file_type: att.type,
          file_size: att.size,
        }));
        
        await supabase.from('order_ticket_attachments').insert(attachmentRecords);
      }

      return ticket;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['order-tickets'] });
      toast({
        title: 'Ticket criado',
        description: 'Seu ticket foi aberto com sucesso. Acompanhe o status aqui.',
      });
    },
    onError: (error: Error) => {
      toast({
        title: 'Erro ao criar ticket',
        description: error.message,
        variant: 'destructive',
      });
    },
  });

  // Update ticket status
  const updateStatusMutation = useMutation({
    mutationFn: async ({ ticketId, status, resolution }: { ticketId: string; status: OrderTicketStatus; resolution?: string }) => {
      const updateData: Record<string, unknown> = { status };
      
      if (status === 'resolvido') {
        updateData.resolved_at = new Date().toISOString();
        if (resolution) {
          updateData.resolution = resolution;
        }
      }

      if (status === 'em_analise' && user) {
        // Mark first response if not already set
        const { data: ticket } = await supabase
          .from('order_tickets')
          .select('first_responded_at')
          .eq('id', ticketId)
          .single();

        if (!ticket?.first_responded_at) {
          updateData.first_responded_at = new Date().toISOString();
        }
      }

      const { error } = await supabase
        .from('order_tickets')
        .update(updateData)
        .eq('id', ticketId);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['order-tickets'] });
      toast({
        title: 'Status atualizado',
        description: 'O status do ticket foi atualizado com sucesso.',
      });
    },
    onError: (error: Error) => {
      toast({
        title: 'Erro ao atualizar status',
        description: error.message,
        variant: 'destructive',
      });
    },
  });

  // Check if order already has an open ticket
  const checkExistingTicket = async (orderId: string): Promise<OrderTicket | null> => {
    const { data, error } = await supabase
      .from('order_tickets')
      .select('*')
      .eq('order_id', orderId)
      .not('status', 'in', '("resolvido","cancelado")')
      .maybeSingle();

    if (error) {
      console.error('Error checking existing ticket:', error);
      return null;
    }

    return data as OrderTicket | null;
  };

  // Get tickets count by status (for badges)
  const { data: ticketCounts } = useQuery({
    queryKey: ['order-tickets-counts', user?.id],
    queryFn: async () => {
      if (!user) return { open: 0, pending: 0 };

      const { data, error } = await supabase
        .from('order_tickets')
        .select('status')
        .in('status', ['aberto', 'em_analise', 'aguardando_cliente']);

      if (error) throw error;

      const counts = {
        open: data.filter(t => t.status === 'aberto').length,
        pending: data.filter(t => ['em_analise', 'aguardando_cliente'].includes(t.status)).length,
        total: data.length,
      };

      return counts;
    },
    enabled: !!user,
  });

  return {
    tickets: tickets || [],
    isLoading,
    error,
    refetch,
    createTicket: createTicketMutation.mutate,
    isCreating: createTicketMutation.isPending,
    updateStatus: updateStatusMutation.mutate,
    isUpdating: updateStatusMutation.isPending,
    getTicketById,
    checkExistingTicket,
    ticketCounts: ticketCounts || { open: 0, pending: 0, total: 0 },
  };
};
